# Device Authentication

## Overview

CountOnMe uses anonymous device-based authentication. There are no user accounts, no email, no passwords. Each mobile device gets a unique identifier and an auth token. This token is used to authenticate all API requests and scope data to the originating device.

## How It Works

### Registration Flow

1. **Client generates a device ID** -- On first launch, `getOrCreateDeviceId()` in `client/src/storage/device.ts` generates a UUID v4 and stores it in AsyncStorage under `device:id`. Subsequent calls return the stored ID.

2. **Client registers with the backend** -- The `registerDevice(deviceId)` function calls `POST /v1/devices/register` with `{ device_id: "<uuid>" }`. This is an unauthenticated endpoint.

3. **Backend issues a token** -- The backend creates a `Device` row (or reuses an existing one), generates a fresh token, stores only the hash, and returns the token.

4. **Client stores the token** -- The token is saved in AsyncStorage under `device:token` via `setDeviceToken()`.

### Token Format

The device token has the format:

```
{device_id}.{secret}
```

Where:
- `device_id` is the UUID identifying the device
- `secret` is a cryptographically random string generated by `secrets.token_urlsafe(32)` (43 characters of URL-safe base64)

Example: `550e8400-e29b-41d4-a716-446655440000.dGhpcyBpcyBhIHNlY3JldCB0b2tlbiBleGFtcGxl`

### Token Storage (Backend)

The backend **never** stores the raw token. Instead, it stores a SHA-256 hash of the secret with a pepper:

```python
hash = SHA-256(secret + "." + DEVICE_TOKEN_PEPPER)
```

The pepper is a server-side secret loaded from environment variables (`settings.device_token_pepper`). This ensures that even if the database is compromised, tokens cannot be reconstructed.

The `devices` table stores:
- `id` (UUID, PK) -- The device ID
- `token_hash` (text) -- The SHA-256 hash of the peppered secret
- `created_at` (timestamp)
- `last_seen_at` (timestamp) -- Updated on every authenticated request

## Authentication Flow (Per Request)

Every API call (except device registration and health check) requires authentication:

### Client Side (`apiFetch` in `client/src/services/api/http.ts`)

1. **Ensure token exists** -- `ensureDeviceToken()` checks AsyncStorage. If no token is stored, it triggers `acquireDeviceToken()` which clears any stale token, calls `registerDevice()`, and stores the new token.

2. **Make the request** -- The token is sent as a Bearer token in the `Authorization` header:
   ```
   Authorization: Bearer {device_id}.{secret}
   ```

3. **Handle 401** -- If the response is 401 (Unauthorized), the client automatically:
   - Calls `acquireDeviceToken()` to re-register and get a fresh token
   - Retries the request exactly once with the new token
   - If the retry also fails, the error propagates to the caller

4. **Handle 403** -- A 403 (Forbidden) is not retried automatically. This indicates active revocation and requires user awareness.

### Concurrent Registration Protection (Client)

A singleton promise (`pendingRegistration`) prevents concurrent device registrations. If multiple API calls detect a missing token simultaneously, they all wait on the same registration promise rather than making parallel registration requests.

### Server Side (`get_current_device` in `backend/app/api/deps.py`)

The authentication dependency chain:

1. **Extract Bearer token** -- `HTTPBearer` extracts the token from the `Authorization` header. Missing or non-Bearer schemes return 401.

2. **Parse token** -- `parse_device_token(token)` splits on "." to extract `device_id` (UUID) and `secret`. Invalid format returns 401.

3. **Look up device** -- `get_device_by_id(session, device_id)` queries the `devices` table. Unknown device ID returns 401.

4. **Verify token** -- `verify_device_token(secret, token_hash)` computes `SHA-256(secret + "." + pepper)` and compares with the stored hash using `hmac.compare_digest()` (constant-time comparison to prevent timing attacks). Mismatch returns 401.

5. **Touch last seen** -- `touch_device_last_seen(session, device)` updates `last_seen_at` to the current UTC time and commits.

6. **Return device** -- The `Device` object is returned. Downstream dependencies use `get_current_device_id` to extract just the `device_id` UUID.

## Rate Limiting

The `POST /v1/devices/register` endpoint is rate-limited to prevent abuse:

- **Limit:** 10 requests per 60 seconds per client IP
- **Implementation:** In-memory sliding-window counter (`RateLimiter` class in `backend/app/api/rate_limit.py`)
- **IP detection:** Uses `X-Forwarded-For` header (first IP) if present, otherwise `request.client.host`
- **Response on limit:** HTTP 429 (Too Many Requests)

## Concurrent Registration Handling (Backend)

The registration endpoint uses `SELECT ... FOR UPDATE` to prevent TOCTOU (Time of Check to Time of Use) race conditions:

1. Attempt to lock the device row with `SELECT ... FOR UPDATE`
2. If no row exists, create a new `Device` with a placeholder `token_hash`
3. If an `IntegrityError` occurs (concurrent insert), rollback and re-fetch the existing device
4. Issue a fresh token and update the `token_hash`
5. Commit the transaction

This ensures that concurrent registration requests for the same `device_id` are serialized and always result in a single valid token.

## Data Scoping

All data in CountOnMe is scoped to a `device_id`:

- **Products** -- `products.device_id`
- **Portions** -- `product_portions.device_id`
- **Food entries** -- `food_entries.device_id`
- **Goals** -- `user_goals.device_id`

Every backend query filters by the authenticated `device_id`. Attempting to access data belonging to another device always returns 404 (not 403), so that the existence of other devices' data is not revealed.

## Client Storage Layout

| Key            | Storage Location        | Description         |
|----------------|-------------------------|---------------------|
| `device:id`    | AsyncStorage            | UUID v4 device ID   |
| `device:token` | AsyncStorage            | Full device token   |

Functions in `client/src/storage/device.ts`:
- `getOrCreateDeviceId()` -- Creates UUID on first call, returns cached value on subsequent calls
- `getDeviceToken()` -- Returns stored token or null
- `setDeviceToken(token)` -- Stores the token
- `clearDeviceToken()` -- Removes the token (triggers re-registration on next API call)
