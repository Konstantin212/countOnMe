---
alwaysApply: false
globs:
  - "client/**/*.tsx"
---

# Component Optimization Guide

## Overview
This document explains the atomic component architecture implemented in the `particles/` folder and how it optimizes form development.

---

## ğŸ“Š Results

### Code Reduction
- **Original ProductFormScreen**: 527 lines
- **Refactored ProductFormScreen**: 335 lines
- **Reduction**: 192 lines (36% smaller)
- **Reusable components**: 7 atomic components

### Benefits
âœ… **DRY Principle** - No repeated form patterns  
âœ… **Type Safety** - Full TypeScript support  
âœ… **Consistent UX** - Uniform styling across all forms  
âœ… **Easy Maintenance** - Update styles in one place  
âœ… **Plug & Play** - Drop components anywhere  
âœ… **Theme Integration** - Automatic theme support  

---

## ğŸ§© Atomic Components (Particles)

### 1. **FormField**
Container wrapper for form sections with consistent padding and borders.

```typescript
<FormField>
  {/* Your form content */}
</FormField>
```

### 2. **Input**
Text input with integrated label and error handling.

**Props:**
- `label?: string` - Input label
- `required?: boolean` - Shows asterisk
- `error?: string` - Error message
- All standard `TextInputProps`

**Example:**
```typescript
<Input
  label="Product Name"
  required
  value={value}
  onChangeText={onChange}
  placeholder="e.g., Chicken Breast"
  maxLength={50}
  error={errors.name?.message}
/>
```

### 3. **NumericInput**
Specialized input for numeric values with automatic parsing.

**Props:**
- `label?: string`
- `required?: boolean`
- `error?: string`
- `value: number | undefined`
- `onChangeValue: (value: number | undefined) => void`
- Other `TextInputProps` (except value/onChangeText)

**Example:**
```typescript
<NumericInput
  label="Calories"
  required
  value={calories}
  onChangeValue={setCalories}
  placeholder="e.g., 165"
  error={errors.calories?.message}
/>
```

### 4. **RadioGroup**
Radio button group with flexible option format.

**Props:**
- `label?: string`
- `required?: boolean`
- `options: readonly T[] | RadioOption<T>[]`
- `value: T`
- `onChange: (value: T) => void`
- `error?: string`

**Example:**
```typescript
// Simple array
<RadioGroup
  label="Scale Type"
  required
  options={['Liquid', 'Solid', 'Dry']}
  value={scaleType}
  onChange={setScaleType}
  error={errors.scaleType?.message}
/>

// With custom labels
<RadioGroup
  label="Size"
  options={[
    { label: 'Small (100g)', value: 100 },
    { label: 'Medium (250g)', value: 250 },
    { label: 'Large (500g)', value: 500 },
  ]}
  value={size}
  onChange={setSize}
/>
```

### 5. **SwitchField**
Toggle switch with label, subtitle, and error support.

**Props:**
- `label: string`
- `subtitle?: string`
- `value: boolean`
- `onValueChange: (value: boolean) => void`
- `error?: string`

**Example:**
```typescript
<SwitchField
  label="Include Nutrients"
  subtitle="Add fat, carbs, and protein information"
  value={includeNutrients}
  onValueChange={setIncludeNutrients}
  error={errors.includeNutrients?.message}
/>
```

### 6. **Button**
Versatile button with variants and loading states.

**Props:**
- `children: ReactNode`
- `variant?: 'primary' | 'secondary' | 'danger'`
- `fullWidth?: boolean` (default: true)
- `loading?: boolean`
- `disabled?: boolean`
- All standard `PressableProps`

**Example:**
```typescript
<Button 
  onPress={handleSubmit} 
  disabled={saving} 
  loading={saving}
>
  Save Product
</Button>

<Button variant="danger" onPress={handleDelete}>
  Delete
</Button>
```

### 7. **Typography Components**
Consistent text components.

#### **Label**
```typescript
<Label required>Product Name</Label>
```

#### **ErrorText**
```typescript
<ErrorText>{errors.name?.message}</ErrorText>
```

#### **SectionTitle**
```typescript
<SectionTitle>Macronutrients</SectionTitle>
```

#### **Subtitle**
```typescript
<Subtitle>Add additional information</Subtitle>
```

---

## ğŸ”„ Migrating Existing Forms

### Before (Repetitive Code)
```typescript
<View style={styles.section}>
  <Text style={styles.label}>
    Product Name <Text style={styles.required}>*</Text>
  </Text>
  <Controller
    control={control}
    name="name"
    render={({ field: { onChange, onBlur, value } }) => (
      <>
        <TextInput
          style={[styles.input, errors.name && styles.inputError]}
          value={value}
          onChangeText={onChange}
          onBlur={onBlur}
          placeholder="e.g., Chicken Breast"
          placeholderTextColor="#999"
          maxLength={50}
        />
        {errors.name && <Text style={styles.errorText}>{errors.name.message}</Text>}
      </>
    )}
  />
</View>
```

### After (Clean & Simple)
```typescript
<FormField>
  <Controller
    control={control}
    name="name"
    render={({ field: { onChange, onBlur, value } }) => (
      <Input
        label="Product Name"
        required
        value={value}
        onChangeText={onChange}
        onBlur={onBlur}
        placeholder="e.g., Chicken Breast"
        maxLength={50}
        error={errors.name?.message}
      />
    )}
  />
</FormField>
```

---

## ğŸ“¦ Import Pattern

```typescript
import {
  FormField,
  Input,
  NumericInput,
  RadioGroup,
  SwitchField,
  Button,
  Label,
  ErrorText,
  SectionTitle,
  Subtitle,
} from '../particles';
```

---

## ğŸ¨ Theme Integration

All components automatically use the theme from `useTheme()` hook:
- Colors
- Border styles
- Typography
- Spacing

To customize appearance, update theme values in `theme/ThemeContext.tsx`.

---

## ğŸ”§ Extending Components

### Adding New Variants
Edit the component file in `particles/` folder.

Example - Adding a new button variant:
```typescript
// particles/Button.tsx
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger' | 'outline'; // Add 'outline'
}

// Add styles
outline: {
  backgroundColor: 'transparent',
  borderWidth: 2,
  borderColor: colors.primary,
},
outlineText: {
  color: colors.primary,
},
```

### Creating New Particles
1. Create component in `particles/` folder
2. Follow existing patterns (theme integration, TypeScript)
3. Export from `particles/index.ts`

---

## ğŸ“ Best Practices

### DO âœ…
- Use atomic components for all new forms
- Keep particles small and focused
- Leverage theme system
- Use TypeScript for props
- Maintain consistent prop naming

### DON'T âŒ
- Add business logic to particles
- Hardcode colors/styles
- Create overly complex particles
- Duplicate particle functionality
- Forget to export from index

---

## ğŸš€ Next Steps

1. **Migrate other forms** - Apply pattern to MealBuilderScreen, etc.
2. **Expand particles** - Add Card, Badge, Modal, etc.
3. **Create molecules** - Combine particles into complex components
4. **Document patterns** - Add Storybook/examples
5. **Unit tests** - Test particle components

---

## ğŸ“š File Structure

```
client/src/
â”œâ”€â”€ particles/              # Atomic components (smallest reusable pieces)
â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”œâ”€â”€ NumericInput.tsx
â”‚   â”œâ”€â”€ RadioGroup.tsx
â”‚   â”œâ”€â”€ SwitchField.tsx
â”‚   â”œâ”€â”€ FormField.tsx
â”‚   â”œâ”€â”€ Typography.tsx
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ components/             # Molecules (composed particles)
â”‚   â”œâ”€â”€ MealItemRow.tsx
â”‚   â””â”€â”€ ProductListItem.tsx
â”œâ”€â”€ screens/                # Organisms (full screens)
â”‚   â””â”€â”€ ProductFormScreen.tsx
â”œâ”€â”€ services/               # Business logic & schemas
â”‚   â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ constants/
â””â”€â”€ hooks/                  # State management
    â””â”€â”€ useProducts.ts
```

This follows **Atomic Design** principles:
- **Particles (Atoms)** - Basic building blocks
- **Components (Molecules)** - Groups of atoms
- **Screens (Organisms)** - Complex UI sections
- **Templates/Pages** - Full layouts

---

## ğŸ¯ ROI Metrics

### Development Speed
- **Form field creation**: ~20 lines â†’ ~8 lines (60% faster)
- **Consistency**: Automatic (no manual style replication)
- **Bug fixes**: One location (affects all instances)

### Maintenance
- **Style updates**: Single file vs. multiple screens
- **Theme changes**: Automatic propagation
- **Refactoring**: Isolated to particle components

### Code Quality
- **Type safety**: Full TypeScript coverage
- **Reusability**: 7 components â†’ âˆ use cases
- **Testability**: Isolated, focused components

---

## ğŸ’¡ Real-World Example Comparison

See `ProductFormScreen.refactored.tsx` for complete refactored example.

**Line count comparison for typical form field:**
- Original: ~25 lines (label, input, error, styles)
- Refactored: ~8 lines (component + props)
- **Savings: 68%**

---

## Questions?

For questions or suggestions about the atomic component system, refer to:
- `CODING_STYLE.md` - General code standards
- `ARCHITECTURE.md` - Overall system design
- Individual component files for implementation details

